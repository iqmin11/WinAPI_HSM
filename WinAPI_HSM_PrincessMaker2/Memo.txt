
wcex.style = CS_HREDRAW | CS_VREDRAW; // WNDCLASS 스타일 지정
CS_VREDRAW : 윈도우 창의 세로크기 변경시 윈도우를 다시 그린다.
CS_HREDRAW : 윈도우 창의 가로크기 변경시 윈도우를 다시 그린다.
CS_DBLCLKS : 마우스 더블클릭 버튼 활성화
CS_OWNDC : 윈도우가 하나의 DC(출력에 필요한 모든 정보를 가지는 데이터 구조체)를 독점적으로 사용한다
CS_CLASSDC : DC를 공유한다
CS_PARENTDC : 자식윈도우가 부모윈도우의 DC를 사용한다
CS_NOCLOSE : 닫기 메세지 전달 불가.
CS_SAVEBITS : 화면영역을 비트맵으로 저장한다






    wcex.lpfnWndProc = MessageFunction; // 
    wcex.cbClsExtra = 0;
    wcex.cbWndExtra = 0;
    wcex.hInstance = _hInstance;
    // 넣어주지 않으면 윈도우 기본Icon이 됩니다.
    wcex.hIcon = nullptr;//LoadIcon(_hInstance, MAKEINTRESOURCE(IDI_WINDOWSPROJECT1));
    wcex.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); // 흰색 
    wcex.lpszMenuName = nullptr;//MAKEINTRESOURCEW(IDC_WINDOWSPROJECT1);
    wcex.lpszClassName = "GameEngineWindowDefault";
    wcex.hIconSm = nullptr;//LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

    // 윈도우에게 이런 내용을 window클래스를 GameEngineWindowDefault라는 이름으로 등록해줘.
    // 나중에 윈도우 만들때 쓸꺼냐.
    if (0 == RegisterClassEx(&wcex))
    {
        MsgAssert("윈도우 클래스 등록에 실패했습니다.");
        return;
    }

    // hInst = hInstance; // 인스턴스 핸들을 전역 변수에 저장합니다.

    // 1000번 프로그램이 윈도우를 띄워달라고 요청했다.
    // 윈도우는 다시 특정 숫자이라는 윈도우가 만들어졌다고 우리에게 알려주는데.
    // 특정 숫자로 인식되는 우리의 윈도우에게 크기변경 떠라

    // (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)

    HWnd = CreateWindow("GameEngineWindowDefault", _TitleName.data(), WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, _hInstance, nullptr);

    if (!HWnd)
    {
        MsgAssert("윈도우 클래스 생성에 실패했습니다.");
        return;
    }

    DrawHdc = GetDC(HWnd);

    ShowWindow(HWnd, SW_SHOW);
    UpdateWindow(HWnd);

    SettingWindowSize(_Size);
    SettingWindowPos(_Pos);

    return;
}



메뉴 프레임 이미지 그리기.
베이스 이미지는 4*4pixel tile이 12*12로 있는
48*48 pixel image
3*3으로 잘라 사용

크기는 픽셀단위로 조정하되, 4로 나누어떨어지지 않으면 생성하지 못하도록 설정을 해야할 듯 함.
위치값은 가운데 값으로 통일하기로했으니 그렇게 해야할듯.

벡터로 생성하여 크기 조정이 가능한 이미지로 생성
메뉴 객체는 내가 직접 생성해주는게 아니라
크리에이터와 클리어 함수를 만들어서 필요할때 만들어야 할듯함.
예를들어 타이틀화면이 생성될때 직접 객체를 생성해주는게아니라, 타이틀화면이 직접 클리어함수를 로드해야하는것이지.

일단 생각만해놓자.

이미지 자르기구현 고고



GameEngineKey
else if (true == press) 프레스 조건 이게 맞음

Up은
Up true, free true 이게 맞음

Up true, free false 이거면
가정: 1프레임 단위로 Up Down 반복 →
첫프레임. 키 입력O Down 및 Press true /
둘프레임. 키 입력X  Up true Free false /
셋 프레임. 키 입력O 로직에 안걸림 그대로 탈출 /
넷프레임. 키 입력X false false false true가 되겠네 /
다섯번째 프레임. Down이 되겠네
문제는 세번쨰 프레임때 입력이 씹혔다는것

GameEngineObject Isdeath 함수 &&에서 ||으로 바꾸기
float4 -단항연산자 만들어줘

달력 몇년도 몇월을 넣으면 그 해당 달의 달력 만들어줘

해야될 일들


1. RPG에서 맵넣고 움직이게 하는거, 카메라, 충돌 구현도 해보기
1-1. 일단 되면 타일맵으로 움직이게 해보자
2. TextOut에 대해서 알아보고 해보기

게임엔진레벨에 겟 액터스 추가
게임엔진렌더에 셋 무브 추가

openinglevel에서 필요한 액터 정리
컷신(적절한 타이밍에 렌더를 바꾸는식으로 설계)
타이틀로고(단순 랜더, 나타날떄 효과같은게 있으면 좋을듯)
머그샷 <-Base단계에서 설계되어야 할 듯함
대화창(머그샷과 메뉴프레임, 텍스트아웃으로 구성, 보여야할 대화창들을 관리)

오늘 알게된거.. 레벨에서 액터를 쓰고싶으면 크리에이트 엑터를 할떄 받아서 써라;;; 난 뭉충이 ㅋㅋ
일단 FirstSetActor 놔두자 ... 건들기 골치아파 위처럼 받아쓰면 더 쉽게 만들 수 있었을것같다.
특정레벨의 Actor를 FSM으로 만들고 싶었어서 필요했었습니다... 
이쪽은 먼저 수정을 하자 이건 좀 아닌듯

lerp는 나중에 게이지 채우는 애니메이션 등을 만들때 사용할 수 있을 것 같음
